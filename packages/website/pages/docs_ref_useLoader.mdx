<Metadata
  title='Reference: useLoader'
  description='API Reference for the useLoader hook in Firebolt.'
/>

# useLoader

The `useLoader` hook allows you to fetch data from a Loader Function which is simply any function that you write alongside your component. Loader Functions have access to server-only resources such as databases that you provide and their code is never exposed to the browser.

```jsx title='components/Profile.js' lineNumbers
import { useLoader } from 'firebolt'

export function Profile({ id }) {
  const loader = useLoader(getUser, id)
  const user = loader.read()
  return (
    <div>
      <div>Name: {user.name}</div>
    </div>
  )
}

export async function getUser(req, id) {
  return await req.db('users').where({ id }).first()
}
```

The component above loads a users data using the `getUser` function and then displays their name.

## useLoader(loaderFn, ...args)

The first argument must be your Loader Function.

Any additional arguments will be passed to the loader function. These arguments are also used to construct a cache key for the data that the function returns and allows you to invalidate or update data in the [cache](/docs/ref/useCache) manually.

The `useLoader` hook returns a loader instance specific to the data being loaded. Loaders are de-duplicated so if your app tries to fetch the same thing in multiple parts of your app it will only be fetched once.

## Loader Function

The loader function must be exported from the same file OR imported from somewhere else.

The first argument provided is a [Request](/docs/ref/request) object.

Any additional arguments from the `useLoader` function will be passed as additional arguments to your loader function.

## loader.read()

Fetches data using the Loader Function and the provided arguments. Firebolt seamlessly handles calling your Loader Function during server-side rendering or on the client behind the scenes.

When `loader.read()` is called in the example above, if there is no data in the cache it will throw a promise triggering any Suspense boundaries you have set up to display loading UI until the data is fetched.

Once the promise resolves the component will re-render and `loader.read()` will return the actual data and the users name will be displayed.

If the loader function fails, the promise will reject and the error will be thrown for an `<ErrorBoundary>` to catch and display custom error messages etc.

## loader.invalidate()

After loading data you may want to refresh it. When data is invalidated it will be refetched in the background and then automatically update your UI. No Suspense boundaries are triggered during a background refetch.

## loader.set(newData)

This method allows you to manually update the data stored in the cache and re-render any components observing that data.

## loader.edit(editFn)

This method, for convenience allows you to make a partial update to your data and automatically handles immutability behind the scenes.

```jsx
loader.edit(user => {
  user.name = 'Bob'
})
```
