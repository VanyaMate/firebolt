export { DocsPage as default } from '../components/DocsPage'
export { components } from '../components/docs-components'

# Loaders

Loaders let you fetch data securely from a database (or anywhere else) directly inside a page or component using the `useData` hook:

```jsx title='components/City.js' lineNumbers
import { Suspense } from 'react'
import { useData } from 'firebolt'

export default function City({ id }) {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <CityContent id={id} />
    </Suspense>
  )
}

function CityContent({ id }) {
  const data = useData(getCity, id)
  const city = data.read()
  return (
    <main>
      <h1>{city.name}</h1>
      <p>{city.description}</p>
    </main>
  )
}

export async function getCity(req, id) {
  return req.db('cities').where({ id }).first()
}
```

Loaders work seamlessly from anywhere in your app and can be used during both server rendering or on the client.

The [Request](/docs/ref/request) object provides utilities to get/set cookies and perform redirects, and you can inject your own utilities such as your database from your [Config](/docs/ref/config) file.

Loader functions are completely removed from client bundles and will not be visible in any client bundles.

## Invalidation

At any time you can invalidate data and it will be refetched in the background. This won't trigger Suspense boundaries and your UI will automatically update with the new data.

```jsx
const data = useData(getCity, '123')
// later on...
data.invalidate()
```

You can also update or invalidate any specific data across your entire app using the [useCache](/docs/ref/useCache) hook.

---

## TODO: move the following to refs docs

Loaders integrate perfectly with Suspense the way React intended. They work seamlessly via server streaming or on the client and you can load data anywhere in your hierarchy.

## useData(fn, ...args)

The first argument to the `useData` hook is the Loader function you want to call.

Any additional arguments are passed to your Loader function and are also used to form a cache key for the data returned by that loader.
These arguments can be used to signal your loader which data to load, but can also be used for tagging data that you might want to invalidate later.

The `useData` hook returns a data resource:

```jsx
const data = useData(getTickets)
const tickets = data.read()
```

In the example above, calling `data.read()` will throw a promise until the Loader responds with data. This triggers any Suspense boundaries and fallback/loading UI until the data is available.

Data resources also have some utility methods for interacting with the cache:

```jsx
// invalidate data to be refetched in the background
data.invalidate()

// replace the data entirely
data.set(newTickets)

// edit the data
data.edit(tickets => tickets.push(ticket))
```

## Loader

The Loader function must be an async function exported from the current file OR an async function imported from somewhere else.

When a Loader function is called, its first argument will be a `Request` object followed by any additional arguments you provided to the `useData` hook.

```jsx
export async function myLoader(req, someId, someOtherThing) {
  // get and return some data...
}
```
